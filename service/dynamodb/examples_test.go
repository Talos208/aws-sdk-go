// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

package dynamodb_test

import (
	"bytes"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/service/dynamodb"
)

var _ time.Duration
var _ bytes.Buffer

func ExampleDynamoDB_BatchGetItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.BatchGetItemInput{
		RequestItems: map[string]*dynamodb.KeysAndAttributes{ // Required
			"Key": { // Required
				Keys: []map[string]*dynamodb.AttributeValue{ // Required
					{ // Required
						"Key": { // Required
							B:    []byte("PAYLOAD"),
							BOOL: aws.BoolPtr(true),
							BS: [][]byte{
								[]byte("PAYLOAD"), // Required
								// More values...
							},
							L: []*dynamodb.AttributeValue{
								{ // Required
								// Recursive values...
								},
								// More values...
							},
							M: map[string]*dynamodb.AttributeValue{
								"Key": { // Required
								// Recursive values...
								},
								// More values...
							},
							N: aws.StringPtr("NumberAttributeValue"),
							NS: []*string{
								aws.StringPtr("NumberAttributeValue"), // Required
								// More values...
							},
							NULL: aws.BoolPtr(true),
							S:    aws.StringPtr("StringAttributeValue"),
							SS: []*string{
								aws.StringPtr("StringAttributeValue"), // Required
								// More values...
							},
						},
						// More values...
					},
					// More values...
				},
				AttributesToGet: []*string{
					aws.StringPtr("AttributeName"), // Required
					// More values...
				},
				ConsistentRead: aws.BoolPtr(true),
				ExpressionAttributeNames: map[string]*string{
					"Key": aws.StringPtr("AttributeName"), // Required
					// More values...
				},
				ProjectionExpression: aws.StringPtr("ProjectionExpression"),
			},
			// More values...
		},
		ReturnConsumedCapacity: aws.StringPtr("ReturnConsumedCapacity"),
	}
	resp, err := svc.BatchGetItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_BatchWriteItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.BatchWriteItemInput{
		RequestItems: map[string][]*dynamodb.WriteRequest{ // Required
			"Key": { // Required
				{ // Required
					DeleteRequest: &dynamodb.DeleteRequest{
						Key: map[string]*dynamodb.AttributeValue{ // Required
							"Key": { // Required
								B:    []byte("PAYLOAD"),
								BOOL: aws.BoolPtr(true),
								BS: [][]byte{
									[]byte("PAYLOAD"), // Required
									// More values...
								},
								L: []*dynamodb.AttributeValue{
									{ // Required
									// Recursive values...
									},
									// More values...
								},
								M: map[string]*dynamodb.AttributeValue{
									"Key": { // Required
									// Recursive values...
									},
									// More values...
								},
								N: aws.StringPtr("NumberAttributeValue"),
								NS: []*string{
									aws.StringPtr("NumberAttributeValue"), // Required
									// More values...
								},
								NULL: aws.BoolPtr(true),
								S:    aws.StringPtr("StringAttributeValue"),
								SS: []*string{
									aws.StringPtr("StringAttributeValue"), // Required
									// More values...
								},
							},
							// More values...
						},
					},
					PutRequest: &dynamodb.PutRequest{
						Item: map[string]*dynamodb.AttributeValue{ // Required
							"Key": { // Required
								B:    []byte("PAYLOAD"),
								BOOL: aws.BoolPtr(true),
								BS: [][]byte{
									[]byte("PAYLOAD"), // Required
									// More values...
								},
								L: []*dynamodb.AttributeValue{
									{ // Required
									// Recursive values...
									},
									// More values...
								},
								M: map[string]*dynamodb.AttributeValue{
									"Key": { // Required
									// Recursive values...
									},
									// More values...
								},
								N: aws.StringPtr("NumberAttributeValue"),
								NS: []*string{
									aws.StringPtr("NumberAttributeValue"), // Required
									// More values...
								},
								NULL: aws.BoolPtr(true),
								S:    aws.StringPtr("StringAttributeValue"),
								SS: []*string{
									aws.StringPtr("StringAttributeValue"), // Required
									// More values...
								},
							},
							// More values...
						},
					},
				},
				// More values...
			},
			// More values...
		},
		ReturnConsumedCapacity:      aws.StringPtr("ReturnConsumedCapacity"),
		ReturnItemCollectionMetrics: aws.StringPtr("ReturnItemCollectionMetrics"),
	}
	resp, err := svc.BatchWriteItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_CreateTable() {
	svc := dynamodb.New(nil)

	params := &dynamodb.CreateTableInput{
		AttributeDefinitions: []*dynamodb.AttributeDefinition{ // Required
			{ // Required
				AttributeName: aws.StringPtr("KeySchemaAttributeName"), // Required
				AttributeType: aws.StringPtr("ScalarAttributeType"),    // Required
			},
			// More values...
		},
		KeySchema: []*dynamodb.KeySchemaElement{ // Required
			{ // Required
				AttributeName: aws.StringPtr("KeySchemaAttributeName"), // Required
				KeyType:       aws.StringPtr("KeyType"),                // Required
			},
			// More values...
		},
		ProvisionedThroughput: &dynamodb.ProvisionedThroughput{ // Required
			ReadCapacityUnits:  aws.Int64Ptr(1), // Required
			WriteCapacityUnits: aws.Int64Ptr(1), // Required
		},
		TableName: aws.StringPtr("TableName"), // Required
		GlobalSecondaryIndexes: []*dynamodb.GlobalSecondaryIndex{
			{ // Required
				IndexName: aws.StringPtr("IndexName"), // Required
				KeySchema: []*dynamodb.KeySchemaElement{ // Required
					{ // Required
						AttributeName: aws.StringPtr("KeySchemaAttributeName"), // Required
						KeyType:       aws.StringPtr("KeyType"),                // Required
					},
					// More values...
				},
				Projection: &dynamodb.Projection{ // Required
					NonKeyAttributes: []*string{
						aws.StringPtr("NonKeyAttributeName"), // Required
						// More values...
					},
					ProjectionType: aws.StringPtr("ProjectionType"),
				},
				ProvisionedThroughput: &dynamodb.ProvisionedThroughput{ // Required
					ReadCapacityUnits:  aws.Int64Ptr(1), // Required
					WriteCapacityUnits: aws.Int64Ptr(1), // Required
				},
			},
			// More values...
		},
		LocalSecondaryIndexes: []*dynamodb.LocalSecondaryIndex{
			{ // Required
				IndexName: aws.StringPtr("IndexName"), // Required
				KeySchema: []*dynamodb.KeySchemaElement{ // Required
					{ // Required
						AttributeName: aws.StringPtr("KeySchemaAttributeName"), // Required
						KeyType:       aws.StringPtr("KeyType"),                // Required
					},
					// More values...
				},
				Projection: &dynamodb.Projection{ // Required
					NonKeyAttributes: []*string{
						aws.StringPtr("NonKeyAttributeName"), // Required
						// More values...
					},
					ProjectionType: aws.StringPtr("ProjectionType"),
				},
			},
			// More values...
		},
	}
	resp, err := svc.CreateTable(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_DeleteItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.DeleteItemInput{
		Key: map[string]*dynamodb.AttributeValue{ // Required
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		TableName:           aws.StringPtr("TableName"), // Required
		ConditionExpression: aws.StringPtr("ConditionExpression"),
		ConditionalOperator: aws.StringPtr("ConditionalOperator"),
		Expected: map[string]*dynamodb.ExpectedAttributeValue{
			"Key": { // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: aws.BoolPtr(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: aws.StringPtr("NumberAttributeValue"),
						NS: []*string{
							aws.StringPtr("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: aws.BoolPtr(true),
						S:    aws.StringPtr("StringAttributeValue"),
						SS: []*string{
							aws.StringPtr("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
				ComparisonOperator: aws.StringPtr("ComparisonOperator"),
				Exists:             aws.BoolPtr(true),
				Value: &dynamodb.AttributeValue{
					B:    []byte("PAYLOAD"),
					BOOL: aws.BoolPtr(true),
					BS: [][]byte{
						[]byte("PAYLOAD"), // Required
						// More values...
					},
					L: []*dynamodb.AttributeValue{
						{ // Required
						// Recursive values...
						},
						// More values...
					},
					M: map[string]*dynamodb.AttributeValue{
						"Key": { // Required
						// Recursive values...
						},
						// More values...
					},
					N: aws.StringPtr("NumberAttributeValue"),
					NS: []*string{
						aws.StringPtr("NumberAttributeValue"), // Required
						// More values...
					},
					NULL: aws.BoolPtr(true),
					S:    aws.StringPtr("StringAttributeValue"),
					SS: []*string{
						aws.StringPtr("StringAttributeValue"), // Required
						// More values...
					},
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": aws.StringPtr("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ReturnConsumedCapacity:      aws.StringPtr("ReturnConsumedCapacity"),
		ReturnItemCollectionMetrics: aws.StringPtr("ReturnItemCollectionMetrics"),
		ReturnValues:                aws.StringPtr("ReturnValue"),
	}
	resp, err := svc.DeleteItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_DeleteTable() {
	svc := dynamodb.New(nil)

	params := &dynamodb.DeleteTableInput{
		TableName: aws.StringPtr("TableName"), // Required
	}
	resp, err := svc.DeleteTable(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_DescribeTable() {
	svc := dynamodb.New(nil)

	params := &dynamodb.DescribeTableInput{
		TableName: aws.StringPtr("TableName"), // Required
	}
	resp, err := svc.DescribeTable(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_GetItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.GetItemInput{
		Key: map[string]*dynamodb.AttributeValue{ // Required
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		TableName: aws.StringPtr("TableName"), // Required
		AttributesToGet: []*string{
			aws.StringPtr("AttributeName"), // Required
			// More values...
		},
		ConsistentRead: aws.BoolPtr(true),
		ExpressionAttributeNames: map[string]*string{
			"Key": aws.StringPtr("AttributeName"), // Required
			// More values...
		},
		ProjectionExpression:   aws.StringPtr("ProjectionExpression"),
		ReturnConsumedCapacity: aws.StringPtr("ReturnConsumedCapacity"),
	}
	resp, err := svc.GetItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_ListTables() {
	svc := dynamodb.New(nil)

	params := &dynamodb.ListTablesInput{
		ExclusiveStartTableName: aws.StringPtr("TableName"),
		Limit: aws.Int64Ptr(1),
	}
	resp, err := svc.ListTables(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_PutItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.PutItemInput{
		Item: map[string]*dynamodb.AttributeValue{ // Required
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		TableName:           aws.StringPtr("TableName"), // Required
		ConditionExpression: aws.StringPtr("ConditionExpression"),
		ConditionalOperator: aws.StringPtr("ConditionalOperator"),
		Expected: map[string]*dynamodb.ExpectedAttributeValue{
			"Key": { // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: aws.BoolPtr(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: aws.StringPtr("NumberAttributeValue"),
						NS: []*string{
							aws.StringPtr("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: aws.BoolPtr(true),
						S:    aws.StringPtr("StringAttributeValue"),
						SS: []*string{
							aws.StringPtr("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
				ComparisonOperator: aws.StringPtr("ComparisonOperator"),
				Exists:             aws.BoolPtr(true),
				Value: &dynamodb.AttributeValue{
					B:    []byte("PAYLOAD"),
					BOOL: aws.BoolPtr(true),
					BS: [][]byte{
						[]byte("PAYLOAD"), // Required
						// More values...
					},
					L: []*dynamodb.AttributeValue{
						{ // Required
						// Recursive values...
						},
						// More values...
					},
					M: map[string]*dynamodb.AttributeValue{
						"Key": { // Required
						// Recursive values...
						},
						// More values...
					},
					N: aws.StringPtr("NumberAttributeValue"),
					NS: []*string{
						aws.StringPtr("NumberAttributeValue"), // Required
						// More values...
					},
					NULL: aws.BoolPtr(true),
					S:    aws.StringPtr("StringAttributeValue"),
					SS: []*string{
						aws.StringPtr("StringAttributeValue"), // Required
						// More values...
					},
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": aws.StringPtr("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ReturnConsumedCapacity:      aws.StringPtr("ReturnConsumedCapacity"),
		ReturnItemCollectionMetrics: aws.StringPtr("ReturnItemCollectionMetrics"),
		ReturnValues:                aws.StringPtr("ReturnValue"),
	}
	resp, err := svc.PutItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_Query() {
	svc := dynamodb.New(nil)

	params := &dynamodb.QueryInput{
		TableName: aws.StringPtr("TableName"), // Required
		AttributesToGet: []*string{
			aws.StringPtr("AttributeName"), // Required
			// More values...
		},
		ConditionalOperator: aws.StringPtr("ConditionalOperator"),
		ConsistentRead:      aws.BoolPtr(true),
		ExclusiveStartKey: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": aws.StringPtr("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		FilterExpression:       aws.StringPtr("ConditionExpression"),
		IndexName:              aws.StringPtr("IndexName"),
		KeyConditionExpression: aws.StringPtr("KeyExpression"),
		KeyConditions: map[string]*dynamodb.Condition{
			"Key": { // Required
				ComparisonOperator: aws.StringPtr("ComparisonOperator"), // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: aws.BoolPtr(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: aws.StringPtr("NumberAttributeValue"),
						NS: []*string{
							aws.StringPtr("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: aws.BoolPtr(true),
						S:    aws.StringPtr("StringAttributeValue"),
						SS: []*string{
							aws.StringPtr("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
			},
			// More values...
		},
		Limit:                aws.Int64Ptr(1),
		ProjectionExpression: aws.StringPtr("ProjectionExpression"),
		QueryFilter: map[string]*dynamodb.Condition{
			"Key": { // Required
				ComparisonOperator: aws.StringPtr("ComparisonOperator"), // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: aws.BoolPtr(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: aws.StringPtr("NumberAttributeValue"),
						NS: []*string{
							aws.StringPtr("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: aws.BoolPtr(true),
						S:    aws.StringPtr("StringAttributeValue"),
						SS: []*string{
							aws.StringPtr("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
			},
			// More values...
		},
		ReturnConsumedCapacity: aws.StringPtr("ReturnConsumedCapacity"),
		ScanIndexForward:       aws.BoolPtr(true),
		Select:                 aws.StringPtr("Select"),
	}
	resp, err := svc.Query(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_Scan() {
	svc := dynamodb.New(nil)

	params := &dynamodb.ScanInput{
		TableName: aws.StringPtr("TableName"), // Required
		AttributesToGet: []*string{
			aws.StringPtr("AttributeName"), // Required
			// More values...
		},
		ConditionalOperator: aws.StringPtr("ConditionalOperator"),
		ExclusiveStartKey: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": aws.StringPtr("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		FilterExpression:       aws.StringPtr("ConditionExpression"),
		IndexName:              aws.StringPtr("IndexName"),
		Limit:                  aws.Int64Ptr(1),
		ProjectionExpression:   aws.StringPtr("ProjectionExpression"),
		ReturnConsumedCapacity: aws.StringPtr("ReturnConsumedCapacity"),
		ScanFilter: map[string]*dynamodb.Condition{
			"Key": { // Required
				ComparisonOperator: aws.StringPtr("ComparisonOperator"), // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: aws.BoolPtr(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: aws.StringPtr("NumberAttributeValue"),
						NS: []*string{
							aws.StringPtr("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: aws.BoolPtr(true),
						S:    aws.StringPtr("StringAttributeValue"),
						SS: []*string{
							aws.StringPtr("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
			},
			// More values...
		},
		Segment:       aws.Int64Ptr(1),
		Select:        aws.StringPtr("Select"),
		TotalSegments: aws.Int64Ptr(1),
	}
	resp, err := svc.Scan(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_UpdateItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.UpdateItemInput{
		Key: map[string]*dynamodb.AttributeValue{ // Required
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		TableName: aws.StringPtr("TableName"), // Required
		AttributeUpdates: map[string]*dynamodb.AttributeValueUpdate{
			"Key": { // Required
				Action: aws.StringPtr("AttributeAction"),
				Value: &dynamodb.AttributeValue{
					B:    []byte("PAYLOAD"),
					BOOL: aws.BoolPtr(true),
					BS: [][]byte{
						[]byte("PAYLOAD"), // Required
						// More values...
					},
					L: []*dynamodb.AttributeValue{
						{ // Required
						// Recursive values...
						},
						// More values...
					},
					M: map[string]*dynamodb.AttributeValue{
						"Key": { // Required
						// Recursive values...
						},
						// More values...
					},
					N: aws.StringPtr("NumberAttributeValue"),
					NS: []*string{
						aws.StringPtr("NumberAttributeValue"), // Required
						// More values...
					},
					NULL: aws.BoolPtr(true),
					S:    aws.StringPtr("StringAttributeValue"),
					SS: []*string{
						aws.StringPtr("StringAttributeValue"), // Required
						// More values...
					},
				},
			},
			// More values...
		},
		ConditionExpression: aws.StringPtr("ConditionExpression"),
		ConditionalOperator: aws.StringPtr("ConditionalOperator"),
		Expected: map[string]*dynamodb.ExpectedAttributeValue{
			"Key": { // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: aws.BoolPtr(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: aws.StringPtr("NumberAttributeValue"),
						NS: []*string{
							aws.StringPtr("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: aws.BoolPtr(true),
						S:    aws.StringPtr("StringAttributeValue"),
						SS: []*string{
							aws.StringPtr("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
				ComparisonOperator: aws.StringPtr("ComparisonOperator"),
				Exists:             aws.BoolPtr(true),
				Value: &dynamodb.AttributeValue{
					B:    []byte("PAYLOAD"),
					BOOL: aws.BoolPtr(true),
					BS: [][]byte{
						[]byte("PAYLOAD"), // Required
						// More values...
					},
					L: []*dynamodb.AttributeValue{
						{ // Required
						// Recursive values...
						},
						// More values...
					},
					M: map[string]*dynamodb.AttributeValue{
						"Key": { // Required
						// Recursive values...
						},
						// More values...
					},
					N: aws.StringPtr("NumberAttributeValue"),
					NS: []*string{
						aws.StringPtr("NumberAttributeValue"), // Required
						// More values...
					},
					NULL: aws.BoolPtr(true),
					S:    aws.StringPtr("StringAttributeValue"),
					SS: []*string{
						aws.StringPtr("StringAttributeValue"), // Required
						// More values...
					},
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": aws.StringPtr("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: aws.BoolPtr(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: aws.StringPtr("NumberAttributeValue"),
				NS: []*string{
					aws.StringPtr("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: aws.BoolPtr(true),
				S:    aws.StringPtr("StringAttributeValue"),
				SS: []*string{
					aws.StringPtr("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ReturnConsumedCapacity:      aws.StringPtr("ReturnConsumedCapacity"),
		ReturnItemCollectionMetrics: aws.StringPtr("ReturnItemCollectionMetrics"),
		ReturnValues:                aws.StringPtr("ReturnValue"),
		UpdateExpression:            aws.StringPtr("UpdateExpression"),
	}
	resp, err := svc.UpdateItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}

func ExampleDynamoDB_UpdateTable() {
	svc := dynamodb.New(nil)

	params := &dynamodb.UpdateTableInput{
		TableName: aws.StringPtr("TableName"), // Required
		AttributeDefinitions: []*dynamodb.AttributeDefinition{
			{ // Required
				AttributeName: aws.StringPtr("KeySchemaAttributeName"), // Required
				AttributeType: aws.StringPtr("ScalarAttributeType"),    // Required
			},
			// More values...
		},
		GlobalSecondaryIndexUpdates: []*dynamodb.GlobalSecondaryIndexUpdate{
			{ // Required
				Create: &dynamodb.CreateGlobalSecondaryIndexAction{
					IndexName: aws.StringPtr("IndexName"), // Required
					KeySchema: []*dynamodb.KeySchemaElement{ // Required
						{ // Required
							AttributeName: aws.StringPtr("KeySchemaAttributeName"), // Required
							KeyType:       aws.StringPtr("KeyType"),                // Required
						},
						// More values...
					},
					Projection: &dynamodb.Projection{ // Required
						NonKeyAttributes: []*string{
							aws.StringPtr("NonKeyAttributeName"), // Required
							// More values...
						},
						ProjectionType: aws.StringPtr("ProjectionType"),
					},
					ProvisionedThroughput: &dynamodb.ProvisionedThroughput{ // Required
						ReadCapacityUnits:  aws.Int64Ptr(1), // Required
						WriteCapacityUnits: aws.Int64Ptr(1), // Required
					},
				},
				Delete: &dynamodb.DeleteGlobalSecondaryIndexAction{
					IndexName: aws.StringPtr("IndexName"), // Required
				},
				Update: &dynamodb.UpdateGlobalSecondaryIndexAction{
					IndexName: aws.StringPtr("IndexName"), // Required
					ProvisionedThroughput: &dynamodb.ProvisionedThroughput{ // Required
						ReadCapacityUnits:  aws.Int64Ptr(1), // Required
						WriteCapacityUnits: aws.Int64Ptr(1), // Required
					},
				},
			},
			// More values...
		},
		ProvisionedThroughput: &dynamodb.ProvisionedThroughput{
			ReadCapacityUnits:  aws.Int64Ptr(1), // Required
			WriteCapacityUnits: aws.Int64Ptr(1), // Required
		},
	}
	resp, err := svc.UpdateTable(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS Error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.StringValue(resp))
}
